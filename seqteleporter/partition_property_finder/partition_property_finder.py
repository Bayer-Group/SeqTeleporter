import math
from typing import Generator, Tuple, List, Optional, Any
import pandas as pd

from seqteleporter.config import ENZYME_INFO, CODON_TABLE
from seqteleporter.partition_property_finder.cost_finder import find_cost
from seqteleporter.partition_property_finder.fragment_length_uneveness_finder import compute_fragment_length_unevenness
from seqteleporter.partition_property_finder.fusion_sites_finder import assign_fusion_sites
from seqteleporter.utils.utils import frag_in_partition_too_short_or_too_long


def find_partition_property(s: str, mutations_0idx: Optional[List[Any]], linked_mutations_0idx: Optional[List[Any]],
                            partitions_list: List[Generator], fidelity_data_path: str,
                            fusion_sites_used_by_backbone: Tuple[str, ...], min_aa_length: int,
                            max_cost: int, max_unevenness: float,
                            min_ligation_fidelity: float, satisfaction_fidelity: float, search_method: str, enzyme: str,
                            analyze_cause_of_no_valid_partition: bool,
                            cost_per_nt: float, provider_min_frag_len: int, provider_max_frag_len: int) -> Generator:
    """
    Parameters:
    - s (str): The DNA sequence to be partitioned.
    - mutations (list): A list of mutation positions within the sequence.
    - number_of_cuts (int): The number of cuts to make in the sequence.
    - fidelity_data_path (str): Path to an Excel file containing experimental data used for assigning fusion sites.
    - min_aa_length (int): The minimum length required for a fragment to be considered valid.
    - max_cost (float): The maximum allowed cost for a partitioning strategy. The cost is calculated based on
                        factors such as enzyme usage and efficiency.
    - max_unevenness (float): The maximum allowed unevenness in fragment lengths. Unevenness is a measure of how
                             dissimilar the lengths of the generated fragments are.
    - min_ligation_fidelity (float): The minimum ligation fidelity required for a partition to be considered valid.
                                     Ligation fidelity is a measure of the accuracy and efficiency of joining the
                                     generated fragments.
    - satisfaction_fidelity (float): The ligation fidelity threshold above which a partition is considered highly
                                     satisfactory.

    Yields:
    - A dictionary for each valid partition containing:
      - 'partition': A tuple representing the positions of the cuts.
      - 'ligation_fidelity': The ligation fidelity for the selected fusion sites, indicating the accuracy and
                             efficiency of fragment joining.
      - 'fragment_length_unevenness': The unevenness of the lengths of the fragments generated by this partition.
      - 'cost': The cost associated with this partitioning strategy.
      - 'fusion_sites': A list of selected fusion sites based on the partition.
      - 'sel_junction_dna_map_fusion_sites': A detailed map of selected junctions and associated fusion sites.
    """

    fidelity_data = pd.read_excel(fidelity_data_path, index_col=0)

    # Generate partitions respecting the hard constraints, compute fragment_length_unevenness and cost
    statisfaction_partition_count = 0
    for partitions in partitions_list:
        for partition in partitions:
            if len(partition) == 0:
                yield {
                    'partition': partition,
                    'ligation_fidelity': 0,
                    'fragment_length_unevenness': 100,
                    'cost': find_cost(s, partition, mutations_0idx, linked_mutations_0idx, enzyme, ENZYME_INFO,
                                      cost_per_nt, provider_min_frag_len, provider_max_frag_len),
                    'fusion_sites': [],
                    'hard_constraint_violation': None,
                    'sel_junction_dna_map_fusion_sites': []
                }
                continue

            if frag_in_partition_too_short_or_too_long(partition, min_aa_length, provider_max_frag_len, enzyme,
                                                       ENZYME_INFO):
                if analyze_cause_of_no_valid_partition:
                    yield f'Fragment(s) too short.'
                continue

            fragment_length_unevenness = compute_fragment_length_unevenness(s, partition)
            if fragment_length_unevenness > max_unevenness:
                if analyze_cause_of_no_valid_partition:
                    yield f'Fragment lengths too uneven.'
                continue

            cost = find_cost(s, partition, mutations_0idx, linked_mutations_0idx, enzyme, ENZYME_INFO, cost_per_nt,
                             provider_min_frag_len, provider_max_frag_len)
            if cost > max_cost or math.isnan(cost):
                if analyze_cause_of_no_valid_partition:
                    yield f'Cost too high.'
                continue

            # Assign fusion sites, compute ligation frequency and mismatch ligation frequency
            sel_fusion_sites, ligation_fidelity, sel_junction_dna_map_sliding_window = \
                assign_fusion_sites(s, mutations_0idx, partition, fidelity_data, satisfaction_fidelity, enzyme,
                                    ENZYME_INFO, fusion_sites_used_by_backbone, search_method, CODON_TABLE)

            if len(sel_fusion_sites) == 0:
                if analyze_cause_of_no_valid_partition:
                    yield f'No fitting fusion sites for all desired mutations.'
                continue

            if ligation_fidelity < min_ligation_fidelity:
                if analyze_cause_of_no_valid_partition:
                    yield f'Ligation fidelity too low.'
                continue

            if ligation_fidelity >= satisfaction_fidelity:
                statisfaction_partition_count += 1

            hard_constraint_violation = 'pass'
            yield {
                'partition': partition,
                'ligation_fidelity': round(ligation_fidelity, 2),
                'fragment_length_unevenness': round(fragment_length_unevenness, 3),
                'cost': round(cost, 2),
                'fusion_sites': sel_fusion_sites,
                'hard_constraint_violation': hard_constraint_violation,
                'sel_junction_dna_map_fusion_sites': sel_junction_dna_map_sliding_window
            }
